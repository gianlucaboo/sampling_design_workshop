---
title: "Workshop on Advanced Sampling Methodologies"
author: "Earth Observation data for sampling"
institute: "Dr. Gianluca Boo, WorldPop, University of Southampton"
date: "09-17-2025"
title-slide-attributes:
  data-background-image: "wp.png"
  data-background-size: "3.2em"
  data-background-position: "90% 10%"
format:
  revealjs: 
    slide-number: true
    incremental: false
    theme: [default, wp_style.scss]
editor: visual
toc: false
toc-title: "Content"
---

## Previously covered

-   Introduction to R and RStudio\
-   Data types and data structures\
-   Importing data\
-   Data manipulation and visualization (`tidyverse`)\
-   Saving and closing sessions

------------------------------------------------------------------------

## Agenda

-   Spatial data in R\
-   Vector and raster data\
-   Packages: `sf` and `terra`\
-   Reading and visualising spatial data\
-   Spatial analysis and visualisation\
-   Remote sensing with Google Hearth Engine

------------------------------------------------------------------------

## Spatial data in R

-   Two main types:
    -   **Vector**: points, lines, polygons
    -   **Raster**: regular grids with values\
-   R packages:
    -   **`sf`**: modern vector handling
    -   **`terra`**: raster analysis\
-   Both integrate well with `ggplot2` for visualisation

------------------------------------------------------------------------

## Vector data

-   **Points**: single locations (e.g., cities, schools)
-   **Lines**: sequences of points (e.g., roads, rivers)
-   **Polygons**: areas (e.g., administrative boundaries)\

![](img/data_vector.png){width="350"}

------------------------------------------------------------------------

## Raster data

-   **Gridded data** with values\
-   Resolution determined by **cell size**\

![](img/data_raster.jpg){width="350"}

------------------------------------------------------------------------

## Reading vector data with `sf`

-   **Simple Features Standard**: implements the Simple Features standard for spatial vector data, allowing consistent and interoperable representation of geometries like points, lines, and polygons.
-   **Data Frame Integration**: stores spatial data in a regular R data frame (or tibble), with a special geometry column, making it easy to manipulate using familiar R tools like dplyr. Efficient
-   **Spatial Operations**: provides a wide range of spatial functions (e.g. intersections, buffers, joins) and interfaces with libraries like GEOS, GDAL, and PROJ for robust, fast, and accurate spatial processing.

```{r}
#| echo: true
library(sf)
admin_boundaries <- 
  "data/pak_adm_wfp_20220909_shp/pak_admbnda_adm1_wfp_20220909.shp" |> 
  st_read(quiet = T)

admin_boundaries |> 
  st_geometry() |> 
  plot()
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## Vector data attributes in `sf`

-   **Simple feature collection**: an `sf` object is a data frame-like structure where each row represents a spatial feature (e.g. a region), and includes attribute fields alongside a geometry column.
-   **Geometry and dimensions**: each feature has a specific geometry type (e.g. MULTIPOLYGON), with defined spatial dimensions (e.g. XY), used to represent shapes on a map.
-   **Spatial metadata**: the object includes spatial metadata such as a coordinate reference system (CRS), e.g. WGS 84, which defines how the geometries relate to real-world locations.

```{r}
#| echo: true
library(sf); library(tidyverse)
admin_boundaries |> 
  select(ADM1_EN) |> 
  head(n=1)
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## Reading raster data with `terra`

-   **Modern Raster and Vector Support**: `terra` provides tools for reading, writing, analyzing, and manipulating raster and vector spatial data, designed as a faster and more efficient successor to the older raster package.
-   **High Performance and Scalability**: built for performance, `terra` can handle large spatial datasets efficiently, supports parallel processing, and integrates well with geospatial libraries like GDAL, PROJ, and GEOS.
-   **Intuitive Syntax and Consistency**: offers a consistent and user-friendly syntax for spatial operations (e.g., cropping, masking, aggregation, reprojection), making it easy to work with complex geospatial workflows in R.

```{r}
#| echo: true
library(terra)
elevation <- 
  "data/pak_elevation_merit103_10km_v1.tif" |> 
  rast()
elevation |> 
plot()
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## Raster data attributes in `terra`

-   **Spatial Structure**: raster data is represented as a `SpatRaster` object with defined dimensions (rows, columns, layers), resolution (cell size), and extent (bounding coordinates of the spatial area).
-   **Coordinate Reference System (CRS)**: each raster includes a `CRS` (e.g., WGS 84, EPSG code) that defines how the raster aligns with real-world geographic space.
-   **Metadata and Values**: rasters store metadata such as source file, layer names, and value ranges (e.g., min and max), which are critical for interpretation and analysis of the data.

```{r}
#| echo: true
library(terra)
elevation
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## `sf::st_crs()` vs `terra::crs()`

-   **SCRS Representation:** in `sf`, `st_crs()` retrieves the CRS of a vector object (e.g., admin_boundaries), while in `terra`, `crs()` is used for raster objects (e.g., elevation) to access or set their CRS.
-   **SCRS Compatibility**: spatial operations between vector and raster data require both to have the same CRS. If they differ, transformation is needed to align them.
-   **SCRS Transformation**: Use `st_transform()` (from `sf`) to reproject vector data to match the CRS of another dataset (e.g., `st_transform(crs(elevation))` ensures admin_boundaries matches the raster CRS).

```{r}
#| echo: true
#| eval: false

st_crs(admin_boundaries)
crs(elevation)

admin_boundaries <- 
  admin_boundaries |> 
  st_transform(crs(elevation))
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## Summarising raster values within polygons

```{r}
#| echo: true
#| eval: true

admin_elevation_mean <- 
  elevation |> 
  terra::extract(admin_boundaries, fun = mean, na.rm = TRUE)
admin_boundaries<- 
  admin_boundaries |> 
  mutate(elevation_mean=admin_elevation_mean[,2])
admin_boundaries |> 
  st_drop_geometry() |> dplyr::select(ADM1_EN, elevation_mean)
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## Vector map in `ggplot2`

```{r}
#| echo: true
#| eval: true
library(ggplot2)
ggplot() +
  geom_sf(data = admin_boundaries, aes(fill=elevation_mean),  color = "black", alpha = 0.3) +
  scale_fill_viridis_c()+
  geom_sf_text(data = admin_boundaries, aes(label = ADM1_EN), size = 3, color = "black") +
  theme_void()+
  labs(title="Mean Elevation", fill= "Elevation (m)")
```

ℹ️ Try to run the code in your Script Editor.

## Raster map in `ggplot2`

```{r}
#| echo: true
#| eval: true
library(ggplot2)
elevation_df <- as.data.frame(elevation, xy = TRUE)
colnames(elevation_df) <- c("x", "y", "elevation")
ggplot(elevation_df) +
  geom_raster(aes(x = x, y = y, fill = elevation)) +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_void()+
  labs(title = "Elevation", fill = "Elevation (m)")
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## Google Earth Engine (GEE)

-   [**Cloud-based platform**](https://earthengine.google.com) for planetary-scale environmental data analysis\
-   **No need to download massive datasets locally**\
-   Access to a variety of **pre-processed datasets** including:
    -   **Satellite imagery:** Landsat, Sentinel-2, MODIS\
    -   **Climate data:** ERA5, CHIRPS precipitation\
    -   **Land cover and vegetation:** Copernicus, GlobCover, NDVI indices\
    -   **Topography:** SRTM, ASTER DEM\
    -   **Socioeconomic:** Population density, night-time lights\

::: embed
<iframe src="https://earthengine.google.com" width="100%" height="350">

</iframe>
:::

------------------------------------------------------------------------

## GEE Code Editor

-   Open [**GEE Code Editor**](https://code.earthengine.google.com/)\
-   **Step-by-step:**
    1.  Sign in with a Google account\
    2.  Click **New Script**\
    3.  Use the **search bar** to find datasets\
    4.  Load the dataset with `ee.ImageCollection` or `ee.Image`\
    5.  Use **filters** (e.g., date, location, bands)\
    6.  Display results with `Map.addLayer()`\
    7.  Export data with `Export.image.toDrive()` or `Export.table.toDrive()`

::: embed
<iframe src="https://code.earthengine.google.com" width="100%" height="350">

</iframe>
:::

------------------------------------------------------------------------

## GEE Example Script

``` javascript
// Example: extract mean NDVI for a region in 2020
var roi = ee.Geometry.Rectangle([34.5, -1.5, 35.5, -0.5]);
var collection = ee.ImageCollection('MODIS/006/MOD13Q1')
                  .filterBounds(roi)
                  .filterDate('2020-01-01', '2020-12-31')
                  .select('NDVI');

var mean_ndvi = collection.mean();
Map.centerObject(roi);
Map.addLayer(mean_ndvi, {min:0, max:9000, palette: ['white','green']}, 'Mean NDVI');

// Export to Google Drive
Export.image.toDrive({
  image: mean_ndvi,
  description: 'mean_ndvi_2020',
  scale: 250,
  region: roi
});
```

ℹ️ Try to run the code in the GEE Script Editor.

------------------------------------------------------------------------

## Downloading data from GEE

Use `Export.image.toDrive()` to save a GeoTIFF

Options:

-   **Scale**: spatial resolution (meters per pixel)

-   **Region**: area of interest (polygon)

-   **CRS**: coordinate reference system

-   **Format**: GeoTIFF for rasters, CSV/GeoJSON for tables

After export, download the file from Google Drive

ℹ️ Try to download the file from Google Drive.

------------------------------------------------------------------------

## Reading GEE data

```{r}
#| echo: true
#| eval: false
library(terra); library(sf); library(ggplot2)

admin_boundaries <- st_read("data/pak_adm_wfp_20220909_shp/pak_admbnda_adm1_wfp_20220909.shp")

ndvi_raster <- rast("data/mean_ndvi_2020.tif")

admin_boundaries <- 
  admin_boundaries |> 
  st_transform(crs(ndvi_raster))

ndvi_mean <- terra::extract(ndvi_raster, polygons, fun = mean, na.rm = TRUE)
admin_boundaries$mean_ndvi <- ndvi_mean[,2]

ggplot(polygons) +
  geom_sf(aes(fill = mean_ndvi)) +
  scale_fill_viridis_c() +
  ggtitle("Mean NDVI per Polygon from GEE")
```

ℹ️ Try to run the code in your Script Editor.

------------------------------------------------------------------------

## Take home

-   Spatial data: vector (sf) vs raster (terra)
-   Always check CRS before analysis
-   Use sf for points, lines, polygons
-   Use terra for raster analysis
-   Combine rasters and vectors for summaries and plots
-   Use GEE to access earth observation data

------------------------------------------------------------------------

## Resources

- [Geocomputation with R](https://geocompr.robinlovelace.net/) — comprehensive online book
- [`sf` package reference](https://r-spatial.github.io/sf/)
- [`terra` package documentation](https://rspatial.org/terra/)
- [GEE Developer Guide](https://developers.google.com/earth-engine)
- [Spatial Data Science in R (RStudio Education)](https://education.rstudio.com/blog/2021/06/spatial-data-in-r/)
- [R Spatial Cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/sf.pdf)

------------------------------------------------------------------------

## Exercise

Please download the R script with exercises from GitHub and try to complete it.
